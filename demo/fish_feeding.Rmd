---
title: "Create a fish feeding EMODnet-Biology data product as NetCDF"
output: 
  html_document:
    code_folding: "show"
    df_print: 'tibble'
    number_section: yes
    code_download: yes
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  collapse = TRUE,
  comment = "#>")
```

# Settings

There are four dependencies. The most important is the [RNetCDF](https://cran.r-project.org/web/packages/RNetCDF/index.html) package. This is a low-level R interface to the file format NetCDF designed by Unidata. Other packages to interact with NetCDF in R are [ncdf4](https://cran.r-project.org/web/packages/ncdf4/) and [tidync](https://cran.r-project.org/web/packages/tidync/).

The rest of libraries are used as helpers.

```{r libraries, warning=FALSE, message=FALSE}
library(RNetCDF)
library(readr)
library(dplyr)
library(glue)
```

# An example data set

This is **a fragment of a real data set**, adjusted to serve as a small example. The names of the columns are [Darwin Core terms](https://dwc.tdwg.org/terms)

```{r read}
load("../data/fish/dat_for_netcdf.Rdata")

dataset <- dat_for_netcdf
str(dataset)
names(dataset)[3] <- "axis"
```

# Arrange the data set

There is one variables of `av_bw_axis_scores`. This is numeric
I think it contains average  biomass in kg per sqkm?
It can be considered that this variable is defined by **four dimensions**: **Spatially**, these are `lon` and `lat`. **Timewise** is the column `year`.

The fourth dimension that defines the variable of interest here is the **axis**, which is shown in the column `axis`. There might be other info about these axes

## Technical constrain: Edit `year`

The `eventDate` **must be transformed to temporal amounts**. These are seconds, days, years etc since a certain date. There is a **helper** in the RNetCDF package: `uitinvcal.nc()`

In this demo, the units will be `days since 1970-01-01 00:00:00`.
Since the time is only provided as a year, we assume the first of january.

```{r date}
dataset$time <- utinvcal.nc(
  unitstring = "days since 1970-01-01 00:00:00" , 
  value = as.POSIXct(paste(dataset$year, "01", "01", sep = "-"), format = "%Y-%m-%d", tz = "UTC")
)

unique(dataset$eventDate)
unique(dataset$time)
```

## Get all possible combination of the dimensions

The key to transform a data frame to netcdf, is that **the data must be transformed into a 4D array**. To do that, **all the possible combinations of the dimensions must be attached**. This will coerce `NA` or empty values in the variable of interest as there will be no value for these combinations.

The base function `expand.grid()` allows to pass vectors and create a data frame with all the possible combinations of those vectors.

```{r coerce_into_array}
# First add an unique identifier by the combination of: 
# decimaLongitude, decimalLatitude, eventDate and AphiaID
dataset <- dataset %>%
  mutate(
    id = glue("{lon}-{lat}-{time}-{axis}")
  )

# Extract the unique and sorted values of the 4 dimensions
lon = sort(unique(dataset$lon))
lat = sort(unique(dataset$lat))
time = sort(unique(dataset$time))
axis = sort(unique(dataset$axis))


# Use expand.grid() to create a data frame with all the possible 
# combinations of the 4 dimensions
longer <- expand.grid(lon = lon, lat = lat, time = time, 
                     axis = axis, 
                     stringsAsFactors = FALSE)


# Define unique identifier again and merge the variable occurrenceStatus 
# with presences and absences

dataset <- dataset %>%
  select(id, av_bw_axis_scores)

longer <- longer %>% 
  mutate(
    id = glue("{lon}-{lat}-{time}-{axis}")
  ) %>%
  left_join(dataset) %>%
  select(-id)

# longer$date <- formatted_time <- as.POSIXct(longer$time *86400, origin = "1970-01-01", tz = "UTC")


# Save for later
write_csv(longer, "../data/derived/longer_fish.csv")

# Inspect
longer
```

## Turn data frame into a 4D array

**NetCDF is designed to host array-oriented scientific data** ([ref](https://docs.unidata.ucar.edu/netcdf-c/current/)). Transforming into an object of type `array` in R will allow the easiest way to add data into a NetCDF file.

In the demo dataset, we know that the **total length of each dimension** are:

-   lon: 29
-   lat: 51
-   time: 24
-   axis: 2

These lengths will be passed to the R function `array()` as a vector: `c(29, 51, 24, 2)`. We will also pass the variable of interest `longer$occurrenceStatus`. However, this variable must have as length the product of all lengths of all dimensions: **This is why we got all the combinations of the dimensions** via `expand.grid()`.

```{r create_array}
# The product of the lengths of all dimensions
29 * 51 * 24 * 2

# Is the same as the length of the variable of interest, including all 
# possible combinations of the dimensions even if this coerce NA's
length(longer$av_bw_axis_scores)

# Create array
array <- array(
  data = longer$av_bw_axis_scores,
  dim = c(length(lon), length(lat), length(time), length(axis))
)
```

Note that this won't always be possible as **adding all the possible combinations makes the variable of interest grow exponentially**. In R, vectors, data frames and arrays are read into memory. It is common that **your machine won't have enough memory** to handle such amount of data.

But worry not: **There are workarounds**. These are discussed later below in this demo.

# Transform into NetCDF

## Create a placeholder

The first step is to **create a netcdf file** that will work as a placeholder to add the data. We use the R package `RNetCDF`

```{r create_nc}
# Create nc file
nc <- create.nc("../data/derived/fish.nc") 
```

## Define dimensions

**Each dimensions has an homonymous variable assigned** along with number of attributes. This is a technical requirement. The dimensions must have the length of the unique values of each dimension.

Some extra attributes must be added to meet the [CF-Convention](http://cfconventions.org/).

In addition, the homonymous variable defining the dimensions **must have their own data**. The data are passed as a 1D vector to `var.put.nc()`, specifying in which variable has to be written.

### Longitude

```{r lon}
# Define lon dimension
dim.def.nc(nc, dimname = "lon", dimlength = length(lon)) 

# Define lon variable
var.def.nc(nc, varname = "lon", vartype = "NC_DOUBLE", dimensions = "lon")

# Add attributes
att.put.nc(nc, variable = "lon", name = "units", type = "NC_CHAR", value = "degrees_east")
att.put.nc(nc, variable = "lon", name = "standard_name", type = "NC_CHAR", value = "longitude")
att.put.nc(nc, variable = "lon", name = "long_name", type = "NC_CHAR", value = "Longitude")

# Put data
var.put.nc(nc, variable = "lon", data = lon) 

# Check
var.get.nc(nc, variable = "lon")
```

### Latitude

```{r lat}
# Define lat dimension
dim.def.nc(nc, dimname = "lat", dimlength = length(lat)) 

# Define lat variable
var.def.nc(nc, varname = "lat", vartype = "NC_DOUBLE", dimensions = "lat")

# Add attributes
att.put.nc(nc, variable = "lat", name = "units", type = "NC_CHAR", value = "degrees_north")
att.put.nc(nc, variable = "lat", name = "standard_name", type = "NC_CHAR", value = "latitude")
att.put.nc(nc, variable = "lat", name = "long_name", type = "NC_CHAR", value = "Latitude")

# Put data
var.put.nc(nc, variable = "lat", data = lat) 

# Check
var.get.nc(nc, variable = "lat")
```

### Time

```{r time}
# Define time dimension
dim.def.nc(nc, dimname = "time", dimlength = length(time)) 

# Define time variable
var.def.nc(nc, varname = "time", vartype = "NC_DOUBLE", dimensions = "time")

# Add attributes
att.put.nc(nc, variable = "time", name = "standard_name", type = "NC_CHAR", value = "time")
att.put.nc(nc, variable = "time", name = "long_name", type = "NC_CHAR", value = "Time")
att.put.nc(nc, variable = "time", name = "units", type = "NC_CHAR", value = "days since 1970-01-01 00:00:00")
att.put.nc(nc, variable = "time", name = "calendar", type = "NC_CHAR", value = "gregorian")

# Put data
var.put.nc(nc, variable = "time", data = time)

# Check
var.get.nc(nc, variable = "time")
```

### Axis

To define the axis dimension, there will be one dimension called `axis`, **with three variables assigned:**

-   `axis`: the actual axis name as a character
-   `taxon_name`: the scientific name of the taxa
-   `taxon_lsid`: the LSID (unique identifier) of the taxa

**These are technical requirements** both for ERDDAP and to meet the [CF-Convention](http://cfconventions.org/).

The dimension `aphiaid` will be used later to define the variable of interest. It is a better practice to use the AphiaID instead of, for instance, the scientific name in `taxon_name`, because **NetCDF works better with numeric data types than with characters.**

Note that **character variables in NetCDF require to be defined also by a dimension typically called "string"**. Its length is the **total number of characters** that can be hosted in the variable of type character. This is a requirement of NetCDF4.

#### axis

I had to make axis numeric so instead of MDS1 and MDS2 it is just 1 and 2

```{r axis}
# Define the axis and string80 dimensions
dim.def.nc(nc, dimname = "axis", dimlength = length(axis))
dim.def.nc(nc, dimname = "string80", dimlength = 80)

# Add axis variable and attributes 
var.def.nc(nc, varname = "axis", vartype = "NC_INT", dimensions = "axis")
att.put.nc(nc, variable = "axis", name = "long_name", type = "NC_CHAR", value = axis_long_name)
att.put.nc(nc, variable = "axis", name = "units", type = "NC_CHAR", value = "level")

# Put axis data
var.put.nc(nc, variable = "axis", data = as.numeric(substring(axis, 4,4)))

# Check
var.get.nc(nc, variable = "axis")
```

#### axis_name

```{r axis_name}
# Add taxon_name variable and attributes
var.def.nc(nc, varname = "axis_name", vartype = "NC_CHAR", dimension = c("string80", "axis"))
att.put.nc(nc, variable = "axis_name", name = "standard_name", type = "NC_CHAR", value = "axis name")
att.put.nc(nc, variable = "axis_name", name = "long_name", type = "NC_CHAR", value = axis_long_name)

# Put taxon_name data
var.put.nc(nc, variable = "axis_name", data = axis)

# Check
var.get.nc(nc, variable = "axis_name")
```

#### taxon_lsid

```{r taxon_lsid, eval = F}
# Add taxon_lsid variable and attributes
var.def.nc(nc, varname = "taxon_lsid", vartype = "NC_CHAR", dimension = c("string80", "aphiaid"))
att.put.nc(nc, variable = "taxon_lsid", name = "standard_name", type = "NC_CHAR", value = "biological_taxon_lsid")
att.put.nc(nc, variable = "taxon_lsid", name = "long_name", type = "NC_CHAR", value = "Life Science Identifier - World Register of Marine Species")

# Put taxon_name data
var.put.nc(nc, variable = "taxon_lsid", data = taxon$taxon_name)

# Check
var.get.nc(nc, variable = "taxon_lsid")
```

### Coordinate Reference System

A non-dimensional variable will be defined to host all the info about the **Coordinate Reference System (CRS)**. This is useful for some GIS software.

**It is assumed that the CRS is WGS84**. If it was different: transform `decimalLatitude` and `decimalLongitude` to WGS84 before hand. See R package `sf`.

```{r crs}
# Define non-dimensional crs variable 
var.def.nc(nc, varname = "crs", vartype = "NC_CHAR", dimensions = NA)

# Add attributes
att.put.nc(nc, variable = "crs", name = "long_name", type = "NC_CHAR", value = "Coordinate Reference System")
att.put.nc(nc, variable = "crs", name = "geographic_crs_name", type = "NC_CHAR", value = "WGS 84")
att.put.nc(nc, variable = "crs", name = "grid_mapping_name", type = "NC_CHAR", value = "latitude_longitude")
att.put.nc(nc, variable = "crs", name = "reference_ellipsoid_name", type = "NC_CHAR", value = "WGS 84")
att.put.nc(nc, variable = "crs", name = "horizontal_datum_name", type = "NC_CHAR", value = "WGS 84")
att.put.nc(nc, variable = "crs", name = "prime_meridian_name", type = "NC_CHAR", value = "Greenwich")
att.put.nc(nc, variable = "crs", name = "longitude_of_prime_meridian", type = "NC_DOUBLE", value = 0.)
att.put.nc(nc, variable = "crs", name = "semi_major_axis", type = "NC_DOUBLE", value = 6378137.)
att.put.nc(nc, variable = "crs", name = "semi_minor_axis", type = "NC_DOUBLE", value = 6356752.314245179)
att.put.nc(nc, variable = "crs", name = "inverse_flattening", type = "NC_DOUBLE", value = 298.257223563)
att.put.nc(nc, variable = "crs", name = "spatial_ref", type = "NC_CHAR", value = 'GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]')
att.put.nc(nc, variable = "crs", name = "GeoTransform", type = "NC_CHAR", value = '-180 0.08333333333333333 0 90 0 -0.08333333333333333 ')
```

## Define the variable of interest

The variable to add the presence/absence data **must be defined by the four dimensions** considered in this demo. This is passed to `var.def.nc()` in the argument `dimensions` as **a vector containing the names of the dimensions.**

The values stating presences and absences are 1 and 0, hence the variable must be of type integer.

Some other attributes are added. E.g. `_FillValue` is a requirement for the CF-Convention stating what value will be used in case of NULL or NA. This is typically `-99999`. The attribute `long_name` is free text and it describes the variable.

```{r def_biomass}
# Create the biomass variable defined by the four dimensions
var.def.nc(nc, varname = "biomass", vartype = "NC_DOUBLE", dimensions = c("lon", "lat", "time", "axis"))

# Add attributes
att.put.nc(nc, variable = "biomass", name = "_FillValue", type = "NC_DOUBLE", value = -99999)
att.put.nc(nc, variable = "biomass", name = "long_name", type = "NC_CHAR", value = av_bw_axis_scores_long_name)
```

If there were a standard name for such a variable in the [CF-Convention](http://cfconventions.org/), this would be add to an attribute named `standard_name`.

### Add data from a 4D Array

As we previously created a 4D array, we can pass this directly to `var.put.nc()`

```{r put_array}
var.put.nc(nc, variable = "biomass", data = array) 

# Check
var.get.nc(nc, variable = "biomass")
```

## Global Attributes

NetCDF files can host **metadata in the form of global attributes**. These contain information such as the author, data of creation, affiliation, citation or license.

See below an example of how defining a number of global attributes and adding them programatically.

**Click on `code` to unfold**

```{r global_att, class.source = "fold-hide"}
attributes <- list(
  title = "Example title",
  summary = "This is the result of a demo to show how to turn a variable defined by four dimensions into a netcdf array.",                       
  Conventions = "CF-1.8",
  # id = "",
  naming_authority = "emodnet-biology.eu",
  history = "https://github.com/EMODnet/EMODnet-Biology-products-erddap-demo",
  source = "https://github.com/EMODnet/EMODnet-Biology-products-erddap-demo",
  # processing_level = "",
  # comment = "", 
  # acknowledgment = "",
  license = "CC-BY",
  standard_name_vocabulary = "CF Standard Name Table v1.8",
  date_created = as.character(Sys.Date()),
  creator_name = "Salvador Fernandez",
  creator_email = "salvador.fernandez@vliz.be",
  creator_url = "www.vliz.be",
  institution = "Flanders Marine Institute (VLIZ)",
  project = "EMODnet-Biology",
  publisher_name = "EMODnet-Biology",                 
  publisher_email = "bio@emodnet.eu",                
  publisher_url = "www.emodnet-biology.eu",                  
  # geospatial_bounds = "",              
  # geospatial_bounds_crs = "",          
  # geospatial_bounds_vertical_crs = "", 
  geospatial_lat_min = min(lat),
  geospatial_lat_max = max(lat),
  geospatial_lon_min = min(lon),
  geospatial_lon_max = max(lon),
  # geospatial_vertical_min = "",        
  # geospatial_vertical_max = "",        
  # geospatial_vertical_positive = "",  
  # time_coverage_start = "1911",            
  # time_coverage_end = "2016",              
  # time_coverage_duration = "",         
  # time_coverage_resolution = "",       
  # uuid = "",                           
  # sea_name = "",                       
  # creator_type = "",                   
  creator_institution = "Flanders Marine Institute (VLIZ)",            
  # publisher_type = "",                 
  publisher_institution = "Flanders Marine Institute (VLIZ)",        
  # program = "",                        
  # contributor_name = "",               
  # contributor_role  = "",              
  geospatial_lat_units = "degrees_north",           
  geospatial_lon_units = "degrees_east",           
  # geospatial_vertical_units   = "",    
  # date_modified = "",               
  # date_issued = "",                    
  # date_metadata_modified   = "",       
  # product_version = "",            
  # keywords_vocabulary = "",          
  # platform  = "",              
  # platform_vocabulary = "",          
  # instrument = "",          
  # instrument_vocabulary  = "",        
  # featureType = "Point",                  
  # metadata_link = "",                  
  # references = "",
  comment = "Uses attributes recommended by http://cfconventions.org",
  license = "CC-BY", 
  publisher_name = "EMODnet Biology Data Management Team",
  citation = "FernÃ¡ndez-Bejarano, Salvador. 2022. Create a EMODnet-Biology data product as NetCDF.",
  acknowledgement = "European Marine Observation Data Network (EMODnet) Biology project (EMFF/2019/1.3.1.9/Lot 6/SI2.837974), funded by the European Union under Regulation (EU) No 508/2014 of the European Parliament and of the Council of 15 May 2014 on the European Maritime and Fisheries Fund"
)

# Define function that detects if the data type should be character of 
# integer and add to global attributes
add_global_attributes <- function(nc, attributes){
  
  stopifnot(is.list(attributes))
  
  for(i in 1:length(attributes)){
    if(is.character(attributes[[i]])){
      type <- "NC_CHAR"
    }else if(is.numeric(attributes[[i]])){
      type <- "NC_DOUBLE"
    }
    att.put.nc(nc, variable = "NC_GLOBAL", name = names(attributes[i]), type = type, value = attributes[[i]])
  }
  sync.nc(nc)
}

# Add attributes
add_global_attributes(nc, attributes)
```

## Wrapping up

Congratulations! The NetCDF file containing the product has been created. Now you can inspect the file.

```{r inspect}
sync.nc(nc)
print.nc(nc)
```

You can read the variables you have created with `var.get.nc`

```{r read_vars}
# Get variable, turn array into vector and get unique values
unique(c(var.get.nc(nc, variable = "presence_absence")))
```

If everything is correct, close the file. Remember it was saved into `./data/derived/foo.nc`

```{r close}
close.nc(nc)
```
